from copy import deepcopy
from typing import Tuple

import cv2
import numpy as np

from utils.builder import PIPELINES


def get_rotated_sigma_matrix(sig_x, sig_y, theta):
    """Calculate the rotated sigma matrix (two dimensional matrix).

    Args:
        sig_x (float): Standard deviation along the horizontal direction.
        sig_y (float): Standard deviation along the vertical direction.
        theta (float): Rotation in radian.

    Returns:
        np.ndarray: Rotated sigma matrix.
    """

    diag = np.array([[sig_x**2, 0], [0, sig_y**2]]).astype(np.float32)
    rot = np.array([[np.cos(theta), -np.sin(theta)],
                    [np.sin(theta), np.cos(theta)]]).astype(np.float32)

    return np.matmul(rot, np.matmul(diag, rot.T))


def _mesh_grid(kernel_size):
    """Generate the mesh grid, centering at zero.

    Args:
        kernel_size (int): The size of the kernel.

    Returns:
        x_grid (np.ndarray): x-coordinates with shape
            (kernel_size, kernel_size).
        y_grid (np.ndarray): y-coordinates with shape
            (kernel_size, kernel_size).
        xy_grid (np.ndarray): stacked coordinates with shape
            (kernel_size, kernel_size, 2).
    """

    range_ = np.arange(-kernel_size // 2 + 1., kernel_size // 2 + 1.)
    x_grid, y_grid = np.meshgrid(range_, range_)
    xy_grid = np.hstack((x_grid.reshape((kernel_size * kernel_size, 1)),
                         y_grid.reshape(kernel_size * kernel_size,
                                        1))).reshape(kernel_size, kernel_size,
                                                     2)

    return xy_grid, x_grid, y_grid


def calculate_gaussian_pdf(sigma_matrix, grid):
    """Calculate PDF of the bivariate Gaussian distribution.

    Args:
        sigma_matrix (np.ndarray): The variance matrix with shape (2, 2).
        grid (np.ndarray): Coordinates generated by :func:`_mesh_grid`,
            with shape (K, K, 2), where K is the kernel size.

    Returns:
        kernel (np.ndarray): Un-normalized kernel.
    """

    inverse_sigma = np.linalg.inv(sigma_matrix)
    kernel = np.exp(-0.5 * np.sum(np.matmul(grid, inverse_sigma) * grid, 2))

    return kernel


def bivariate_gaussian(kernel_size,
                       sig_x,
                       sig_y=None,
                       theta=None,
                       grid=None,
                       is_isotropic=True):
    """Generate a bivariate isotropic or anisotropic Gaussian kernel.

    In isotropic mode, only `sig_x` is used. `sig_y` and `theta` are
    ignored.

    Args:
        kernel_size (int): The size of the kernel
        sig_x (float): Standard deviation along horizontal direction.
        sig_y (float | None, optional): Standard deviation along the vertical
            direction. If it is None, 'is_isotropic' must be set to True.
            Default: None.
        theta (float | None, optional): Rotation in radian. If it is None,
            'is_isotropic' must be set to True. Default: None.
        grid (ndarray, optional): Coordinates generated by :func:`_mesh_grid`,
            with shape (K, K, 2), where K is the kernel size. Default: None
        is_isotropic (bool, optional): Whether to use an isotropic kernel.
            Default: True.

    Returns:
        kernel (np.ndarray): normalized kernel (i.e. sum to 1).
    """

    if grid is None:
        grid, _, _ = _mesh_grid(kernel_size)

    if is_isotropic:
        sigma_matrix = np.array([[sig_x**2, 0], [0,
                                                 sig_x**2]]).astype(np.float32)
    else:
        if sig_y is None:
            raise ValueError('"sig_y" cannot be None if "is_isotropic" is '
                             'False.')

        sigma_matrix = get_rotated_sigma_matrix(sig_x, sig_y, theta)

    kernel = calculate_gaussian_pdf(sigma_matrix, grid)
    kernel = kernel / np.sum(kernel)

    return kernel


def random_bivariate_gaussian_kernel(kernel_size,
                                     sigma_x_range,
                                     sigma_y_range,
                                     rotation_range,
                                     noise_range=None,
                                     is_isotropic=True):
    """Randomly generate bivariate isotropic or anisotropic Gaussian kernels.

    In the isotropic mode, only `sigma_x_range` is used. `sigma_y_range` and
    `rotation_range` is ignored.

    Args:
        kernel_size (int): The size of the kernel.
        sigma_x_range (tuple): The range of the standard deviation along the
            horizontal direction. Default: [0.6, 5]
        sigma_y_range (tuple): The range of the standard deviation along the
            vertical direction. Default: [0.6, 5]
        rotation_range (tuple): Range of rotation in radian.
        noise_range (tuple, optional): Multiplicative kernel noise.
            Default: None.
        is_isotropic (bool, optional): Whether to use an isotropic kernel.
            Default: True.

    Returns:
        kernel (np.ndarray): The kernel whose parameters are sampled from the
            specified range.
    """

    assert kernel_size % 2 == 1, 'Kernel size must be an odd number.'
    assert sigma_x_range[0] <= sigma_x_range[1], 'Wrong sigma_x_range.'

    sigma_x = np.random.uniform(sigma_x_range[0], sigma_x_range[1])
    if is_isotropic is False:
        assert sigma_y_range[0] <= sigma_y_range[1], 'Wrong sigma_y_range.'
        assert rotation_range[0] <= rotation_range[1], 'Wrong rotation_range.'
        sigma_y = np.random.uniform(sigma_y_range[0], sigma_y_range[1])
        rotation = np.random.uniform(rotation_range[0], rotation_range[1])
    else:
        sigma_y = sigma_x
        rotation = 0

    kernel = bivariate_gaussian(
        kernel_size, sigma_x, sigma_y, rotation, is_isotropic=is_isotropic)

    # add multiplicative noise
    if noise_range is not None:
        assert noise_range[0] <= noise_range[1], 'Wrong noise range.'
        noise = np.random.uniform(
            noise_range[0], noise_range[1], size=kernel.shape)
        kernel = kernel * noise
    kernel = kernel / np.sum(kernel)

    return kernel

@PIPELINES.register_module()
class RandomBlur:

    def __init__(self,
                 bins: int or list,
                 kernel_size: int,
                 sigma_range: Tuple[float, float],
                 rotate_angle: Tuple[float, float]=[-3.1416, 3.1416]):
        self.bins = bins
        self.kernel_size = kernel_size
        self.sigma_range = sigma_range
        self.rotate_angle = rotate_angle
        num_bins = bins if type(bins) is int else len(bins)
        sigma_length = sigma_range[1] - sigma_range[0]
        if type(bins) is int:
            interval = sigma_length / self.bins
            init = sigma_range[0]
            self.bins = [(init + interval*n, init + interval*(n+1))
                                for n in range(bins)]
        else:
            self.bins = bins
        # Initialize in uniform distribution
        self.p = [1.0 / num_bins for _ in range(num_bins)]

    def __call__(self, x: np.ndarray, idx: int=None):
        if idx is None:
            idx = np.random.choice(len(self.bins), size=1, p=self.p)[0]
        sigma_range = self.bins[idx]
        kernel = random_bivariate_gaussian_kernel(self.kernel_size,
                                                sigma_range,
                                                sigma_range,
                                                self.rotate_angle)
        x_blurred = cv2.filter2D(x, -1, kernel)
        return x_blurred, idx

    def update_weight(self, new_p: list):
        assert len(self.p) == len(new_p)
        self.p = deepcopy(new_p)


if __name__ == '__main__':
    random_blur = RandomBlur(bins=5, kernel_size=3, sigma_range=[0, 5])
    x = np.random.rand(128, 128, 3)
    print('sample weights:', random_blur.p)
    print('bins:', random_blur.bins)
    x_blurred, idx = random_blur(x)
    print(x.shape, x_blurred.shape, idx)
